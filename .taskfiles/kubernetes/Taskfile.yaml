# yaml-language-server: $schema=https://taskfile.dev/schema.json
version: "3"

tasks:
  default: task --list --taskfile "{{.ROOT_DIR}}/.taskfiles/kubernetes/Taskfile.yaml"

  fetch-kubeconfig:
    desc: Fetch kubeconfig for the kubernetes cluster
    cmds: 
      - k3d kubeconfig get {{.CLUSTER_NAME}} > {{.KUBECONFIG_PATH}}
      - chmod 0600 {{.KUBECONFIG_PATH}}
    preconditions:
      - msg: "K3D cluster {{.CLUSTER_NAME}} not found"
        sh: k3d cluster list | grep -q {{.CLUSTER_NAME}}
    status:
      - test -f {{.KUBECONFIG_PATH}} && grep -q {{.CLUSTER_NAME}} {{.KUBECONFIG_PATH}}

  customize-coredns:
    desc: Apply custom CoreDNS configuration and restart CoreDNS deployment
    cmds:
      - kubectl --kubeconfig {{.KUBECONFIG_PATH}} apply -f {{.K8S_DIR}}/config/coredns-custom.yaml
      - kubectl --kubeconfig {{.KUBECONFIG_PATH}} rollout restart deployment coredns -n kube-system
    status:
      - kubectl --kubeconfig {{.KUBECONFIG_PATH}} get deployment coredns -n kube-system
      - kubectl --kubeconfig {{.KUBECONFIG_PATH}} get configmap coredns-custom -n kube-system

  create-wildcard-cert:
    desc: Create a wildcard certificate for the local domain and deploy it to the cluster
    cmds:
      - kubectl --kubeconfig {{.KUBECONFIG_PATH}} create secret tls wildcard-tls --cert={{.K8S_DIR}}/certs/{{.LOCAL_DOMAIN}}.pem --key={{.K8S_DIR}}/certs/{{.LOCAL_DOMAIN}}-key.pem -n kube-system
    status:
      - kubectl --kubeconfig {{.KUBECONFIG_PATH}} get secret wildcard-tls -n kube-system

  deploy-services:
    desc: Deploy core services using helmfile
    cmds:
      - helmfile --file {{.K8S_DIR}}/config/helmfile.yaml apply --kubeconfig {{.KUBECONFIG_PATH}} --skip-diff-on-install --suppress-diff
    status:
      - helmfile --file {{.K8S_DIR}}/config/helmfile.yaml status --kubeconfig {{.KUBECONFIG_PATH}}

  label-worker-nodes:
    desc: "Label worker/agent nodes with node-role.kubernetes.io/worker=true"
    cmds:
      - |
        echo "ðŸ”„ Labeling worker/agent nodes..."
        for ((i=0; i<{{.WORKERS}}; i++)); do
          NODE_NAME="k3d-{{.CLUSTER_NAME}}-agent-${i}"
          if ! kubectl --kubeconfig {{.KUBECONFIG_PATH}} get node ${NODE_NAME} -o jsonpath='{.metadata.labels}' | grep -q 'node-role\.kubernetes\.io/worker'; then
            kubectl --kubeconfig {{.KUBECONFIG_PATH}} label node ${NODE_NAME} node-role.kubernetes.io/worker=true --overwrite
            echo "âœ… Labeled node ${NODE_NAME} as worker"
          else
            echo "â„¹ï¸ Node ${NODE_NAME} is already labeled as worker"
          fi
        done
    status:
      - |
        LABELED_COUNT=0
        for ((i=0; i<{{.WORKERS}}; i++)); do
          NODE_NAME="k3d-{{.CLUSTER_NAME}}-agent-${i}"
          if kubectl --kubeconfig {{.KUBECONFIG_PATH}} get node ${NODE_NAME} -o jsonpath='{.metadata.labels}' | grep -q 'node-role\.kubernetes\.io/worker'; then
            ((LABELED_COUNT++))
          fi
        done
        [ "$LABELED_COUNT" -eq "{{.WORKERS}}" ]

  fetch-service-secrets:
    desc: "Fetch and decode passwords for enabled services and write them to a file"
    cmds:
      - |
        # Fetch the list of enabled, password-protected services
        PASSWORD_PROTECTED_SERVICES=($(yq e '.environment.services[] | select(.enabled == true and .password-protected == true) | .name' {{.CONFIG_FILE}}))
        OUTPUT_FILE="{{.K8S_DIR}}/service-secrets.txt"
        > $OUTPUT_FILE  # Clear the file before writing

        for SERVICE in "${PASSWORD_PROTECTED_SERVICES[@]}"; do
          SECRET_NAME=$(yq e ".environment.services[] | select(.name == \"$SERVICE\").secret-name" {{.CONFIG_FILE}})  # Get secret name
          PASSWORD_FIELD=$(yq e ".environment.services[] | select(.name == \"$SERVICE\").password-field" {{.CONFIG_FILE}})  # Get password field
          PASSWORD=$(kubectl get secret $SECRET_NAME -n $SERVICE -o jsonpath="{.data.$PASSWORD_FIELD}" | base64 --decode)
          echo "Service $SERVICE, Password: $PASSWORD" >> $OUTPUT_FILE
        done

        if [ -s "$OUTPUT_FILE" ]; then
          echo "ðŸ”‘ Passwords for enabled password-protected services have been written to $OUTPUT_FILE"
        fi
