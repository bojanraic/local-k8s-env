# yaml-language-server: $schema=https://taskfile.dev/schema.json
version: "3"

tasks:
  default: task --list --taskfile "{{.ROOT_DIR}}/.taskfiles/kubernetes/Taskfile.yaml"

  wait-for-ready:
    desc: Wait for the cluster to be ready
    silent: true
    cmds:
      - |
        echo "⏳ Waiting for {{.PROVIDER}} cluster..."
        
        # Set context and verify connection
        kubectl --kubeconfig {{.KUBECONFIG_PATH}} config use-context {{.PROVIDER}}-{{.CLUSTER_NAME}}
        
        # Give the API server a moment to initialize
        sleep 3
        
        # Wait for all nodes to be ready
        kubectl --kubeconfig {{.KUBECONFIG_PATH}} wait --for=condition=Ready nodes --all
        echo "✅ Cluster is ready"

  fetch-kubeconfig:
    desc: Fetch kubeconfig for the kubernetes cluster
    silent: true
    cmds:
      - |
        {{.PROVIDER_BINARY}} get kubeconfig --name {{.CLUSTER_NAME}} > {{.KUBECONFIG_PATH}}
      - chmod 0600 {{.KUBECONFIG_PATH}}
    preconditions:
      - msg: "{{.PROVIDER}} cluster {{.CLUSTER_NAME}} not found"
        sh: |
          {{.PROVIDER_BINARY}} get clusters | grep -q {{.CLUSTER_NAME}}
    status:
      - test -f {{.KUBECONFIG_PATH}} && grep -q {{.CLUSTER_NAME}} {{.KUBECONFIG_PATH}}

  setup-helm-repos:
    desc: Setup Helm repositories required by helmfile
    silent: true
    cmds:
      - echo "🔄 Setting up Helm repositories..."
      - |
        # Add repositories if they don't exist
        if ! helm repo list | grep -q "^ingress-nginx"; then
          echo "  📦 Adding ingress-nginx repository..."
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx >/dev/null
        else
          echo "  📦 Updating ingress-nginx repository..."
          helm repo update ingress-nginx >/dev/null
        fi
        
        if ! helm repo list | grep -q "^groundhog2k"; then
          echo "  📦 Adding groundhog2k repository..."
          helm repo add groundhog2k https://groundhog2k.github.io/helm-charts/ >/dev/null
        else
          echo "  📦 Updating groundhog2k repository..."
          helm repo update groundhog2k >/dev/null
        fi
        
        if ! helm repo list | grep -q "^bjw-s-labs"; then
          echo "  📦 Adding bjw-s-labs repository..."
          helm repo add bjw-s-labs https://bjw-s-labs.github.io/helm-charts/ >/dev/null
        else
          echo "  📦 Updating bjw-s-labs repository..."
          helm repo update bjw-s-labs >/dev/null
        fi
      - echo "✅ Helm repositories setup complete"
    status:
      - |
        # Check if all required repositories are present
        helm repo list | grep -q "ingress-nginx" && \
        helm repo list | grep -q "groundhog2k" && \
        helm repo list | grep -q "bjw-s-labs"

  setup-wildcard-cert:
    desc: Create wildcard TLS certificate secret for nginx-ingress
    silent: true
    cmds:
      - echo "🔄 Creating wildcard TLS secret..."
      - |
        # Create kube-system namespace if it doesn't exist
        kubectl --kubeconfig {{.KUBECONFIG_PATH}} create namespace kube-system --dry-run=client -o yaml | kubectl --kubeconfig {{.KUBECONFIG_PATH}} apply -f -
        
        # Create wildcard TLS secret
        kubectl --kubeconfig {{.KUBECONFIG_PATH}} create secret tls wildcard-tls \
          --namespace kube-system \
          --cert={{.CERT_FILE}} \
          --key={{.KEY_FILE}} \
          --dry-run=client -o yaml | \
          kubectl --kubeconfig {{.KUBECONFIG_PATH}} apply -f -
      - echo "✅ Wildcard TLS secret created"
    status:
      - kubectl --kubeconfig {{.KUBECONFIG_PATH}} get secret wildcard-tls -n kube-system >/dev/null 2>&1



  deploy-services:
    desc: Deploy remaining services using helmfile
    silent: true
    deps: [setup-helm-repos, setup-wildcard-cert]
    cmds:
      - echo "🔄 Deploying services..."
      - |
        echo "  📦 Installing/upgrading Helm charts for enabled services..."
        helmfile --file {{.K8S_DIR}}/config/helmfile.yaml \
          apply --kubeconfig {{.KUBECONFIG_PATH}} --skip-diff-on-install --suppress-diff
      - echo "✅ Services deployed successfully"
    status:
      - helmfile --file {{.K8S_DIR}}/config/helmfile.yaml status --kubeconfig {{.KUBECONFIG_PATH}}

  label-worker-nodes:
    desc: "Label worker/agent nodes with node-role.kubernetes.io/worker=true"
    silent: true
    cmds:
      - |
        echo "🔄 Labeling worker nodes..."
        for ((i=0; i<{{.WORKERS}}; i++)); do
          if [ $i -eq 0 ]; then
            NODE_NAME="{{.CLUSTER_NAME}}-worker"
          else
            NODE_NAME="{{.CLUSTER_NAME}}-worker$((i+1))"
          fi
          if ! kubectl --kubeconfig {{.KUBECONFIG_PATH}} get node ${NODE_NAME} -o jsonpath='{.metadata.labels}' | grep -q 'node-role\.kubernetes\.io/worker'; then
            kubectl --kubeconfig {{.KUBECONFIG_PATH}} label node ${NODE_NAME} node-role.kubernetes.io/worker=true --overwrite
            echo "✅ Labeled node ${NODE_NAME} as worker"
          else
            echo "ℹ️ Node ${NODE_NAME} is already labeled as worker"
          fi
        done
    status:
      - |
        LABELED_COUNT=0
        for ((i=0; i<{{.WORKERS}}; i++)); do
          if [ $i -eq 0 ]; then
            NODE_NAME="{{.CLUSTER_NAME}}-worker"
          else
            NODE_NAME="{{.CLUSTER_NAME}}-worker$((i+1))"
          fi
          if kubectl --kubeconfig {{.KUBECONFIG_PATH}} get node ${NODE_NAME} -o jsonpath='{.metadata.labels}' | grep -q 'node-role\.kubernetes\.io/worker'; then
            ((LABELED_COUNT++))
          fi
        done
        [ "$LABELED_COUNT" -eq "{{.WORKERS}}" ]

  fetch-service-secrets:
    desc: Fetch secrets for enabled services
    silent: true
    cmds:
      - echo "🔄 Fetching service secrets..."
      - |
        # Get all deployed helm releases
        RELEASES=$(helm --kubeconfig {{.KUBECONFIG_PATH}} list --all-namespaces -o json)
        
        if [ "$(echo "$RELEASES" | jq length)" -eq 0 ]; then
          echo "ℹ️ No Helm releases found. Deploy services first."
          exit 0
        fi
        
        OUTPUT_FILE="{{.K8S_DIR}}/service-secrets.txt"
        > $OUTPUT_FILE  # Clear the file before writing
        
        echo "  🔍 Extracting passwords from Helm release values..."
        
        # Service configurations with value paths in Helm charts
        declare -A SERVICE_CONFIGS
        SERVICE_CONFIGS["mysql"]="root:settings.rootPassword.value"
        SERVICE_CONFIGS["postgres"]="postgres:settings.superuserPassword.value"
        SERVICE_CONFIGS["mongodb"]="root:settings.rootPassword"
        SERVICE_CONFIGS["rabbitmq"]="admin:authentication.password.value"
        
        for SERVICE in "${!SERVICE_CONFIGS[@]}"; do
          # Check if service is deployed
          RELEASE_INFO=$(echo "$RELEASES" | jq -r ".[] | select(.name == \"$SERVICE\") | .namespace")
          
          if [ -n "$RELEASE_INFO" ] && [ "$RELEASE_INFO" != "null" ]; then
            NAMESPACE="$RELEASE_INFO"
            echo "  📦 Found deployed service: $SERVICE in namespace: $NAMESPACE"
            
            # Extract username and value path from config
            USERNAME=$(echo "${SERVICE_CONFIGS[$SERVICE]}" | cut -d: -f1)
            VALUE_PATH=$(echo "${SERVICE_CONFIGS[$SERVICE]}" | cut -d: -f2)
            
            # Get the Helm values and extract password
            VALUES=$(helm --kubeconfig {{.KUBECONFIG_PATH}} get values "$SERVICE" -n "$NAMESPACE" -o json 2>/dev/null)
            
            if [ -n "$VALUES" ] && [ "$VALUES" != "null" ]; then
              # Use jq to extract the password from the nested path
              PASSWORD=$(echo "$VALUES" | jq -r ".$VALUE_PATH // empty" 2>/dev/null)
              
              if [ -n "$PASSWORD" ] && [ "$PASSWORD" != "null" ]; then
                echo "Service $SERVICE (namespace: $NAMESPACE), Username: $USERNAME, Password: $PASSWORD" >> $OUTPUT_FILE
                echo "    ✅ Retrieved password for $SERVICE"
              else
                echo "    ⚠️ Password not found at path '$VALUE_PATH' for $SERVICE"
              fi
            else
              echo "    ⚠️ Could not retrieve Helm values for $SERVICE"
            fi
          fi
        done
        
        if [ -s "$OUTPUT_FILE" ]; then
          echo ""
          echo "🔑 Service secrets:"
          cat $OUTPUT_FILE
          echo ""
          echo "✅ Service secrets fetched successfully"
          echo "📝 Secrets saved to: $OUTPUT_FILE"
        else
          echo "⚠️ No service secrets found. Services may not be deployed yet or passwords may not be in Helm values."
        fi

  create-cluster:
    desc: Create a new {{.PROVIDER}} cluster
    silent: true
    status:
      - test -f {{.K8S_DIR}}/config/cluster.yaml
      - |
        {{.PROVIDER_BINARY}} get clusters | grep -q {{.CLUSTER_NAME}}
    cmds:
      - echo "🔄 Creating {{.PROVIDER}} cluster '{{.CLUSTER_NAME}}'..."
      - |
        {{.PROVIDER_BINARY}} create cluster --config {{.K8S_DIR}}/config/cluster.yaml --name {{.CLUSTER_NAME}}
      - echo "✅ {{.PROVIDER_BINARY}} cluster '{{.CLUSTER_NAME}}' created successfully"

  delete-cluster:
    desc: Delete the kubernetes cluster
    silent: true
    cmds:
      - |
        {{.PROVIDER_BINARY}} delete cluster --name {{.CLUSTER_NAME}}

  recreate-cluster:
    desc: Recreate the kubernetes cluster
    silent: true
    cmds:
      - task: delete-cluster
      - task: create-cluster

  set-control-plane-scheduling:
    desc: "Set scheduling on control plane nodes"
    silent: true
    cmds:
      - |
        if [ "{{.ALLOW_CONTROL_PLANE_SCHEDULING}}" = "true" ]; then
          echo "🔄 Enabling scheduling on control plane nodes..."
          # Remove taint if it exists, suppress errors
          kubectl --kubeconfig {{.KUBECONFIG_PATH}} taint nodes --all node-role.kubernetes.io/control-plane:NoSchedule- 2>/dev/null || true
          echo "✅ Scheduling enabled on control plane nodes"
        else
          echo "🔄 Disabling scheduling on control plane nodes..."
          kubectl --kubeconfig {{.KUBECONFIG_PATH}} taint nodes --overwrite --selector node-role.kubernetes.io/control-plane node-role.kubernetes.io/control-plane:NoSchedule
          echo "✅ Scheduling disabled on control plane nodes"
        fi

  list-nodes:
    desc: List cluster nodes
    silent: true
    cmds:
      - echo "🔄 Listing cluster nodes..."
      - kubectl --kubeconfig {{.KUBECONFIG_PATH}} get nodes
      - echo "✅ Node list complete"

  helmfile-apply:
    desc: Apply helmfile configuration
    silent: true
    cmds:
      - |
        echo "🔄 Applying helmfile configuration..."
        helmfile --file {{.K8S_DIR}}/config/helmfile.yaml apply
        echo "✅ Helmfile configuration applied"

  helmfile-destroy:
    desc: Destroy helmfile configuration
    silent: true
    cmds:
      - |
        echo "🔄 Destroying helmfile configuration..."
        helmfile --file {{.K8S_DIR}}/config/helmfile.yaml destroy
        echo "✅ Helmfile configuration destroyed"
