# yaml-language-server: $schema=https://taskfile.dev/schema.json
version: "3"

tasks:
  default: task --list --taskfile "{{.ROOT_DIR}}/.taskfiles/kubernetes/Taskfile.yaml"

  fetch-kubeconfig:
    desc: Fetch kubeconfig for the kubernetes cluster
    cmds: 
      - k3d kubeconfig get {{.CLUSTER_NAME}} > {{.KUBECONFIG_PATH}}
      - chmod 0600 {{.KUBECONFIG_PATH}}
    preconditions:
      - msg: "K3D cluster {{.CLUSTER_NAME}} not found"
        sh: k3d cluster list | grep -q {{.CLUSTER_NAME}}
    status:
      - test -f {{.KUBECONFIG_PATH}} && grep -q {{.CLUSTER_NAME}} {{.KUBECONFIG_PATH}}

  customize-coredns:
    desc: Apply custom CoreDNS configuration and restart CoreDNS deployment
    cmds:
      - kubectl --kubeconfig {{.KUBECONFIG_PATH}} apply -f {{.K8S_DIR}}/config/coredns-custom.yaml
      - kubectl --kubeconfig {{.KUBECONFIG_PATH}} rollout restart deployment coredns -n kube-system
    status:
      - kubectl --kubeconfig {{.KUBECONFIG_PATH}} get deployment coredns -n kube-system
      - kubectl --kubeconfig {{.KUBECONFIG_PATH}} get configmap coredns-custom -n kube-system

  create-wildcard-cert:
    desc: Create a wildcard certificate for the local domain and deploy it to the cluster
    cmds:
      - kubectl --kubeconfig {{.KUBECONFIG_PATH}} create secret tls wildcard-tls --cert={{.K8S_DIR}}/certs/{{.LOCAL_DOMAIN}}.pem --key={{.K8S_DIR}}/certs/{{.LOCAL_DOMAIN}}-key.pem -n kube-system
    status:
      - kubectl --kubeconfig {{.KUBECONFIG_PATH}} get secret wildcard-tls -n kube-system

  deploy-services:
    desc: Deploy core services using helmfile
    cmds:
      - helmfile --file {{.K8S_DIR}}/config/helmfile.yaml apply --kubeconfig {{.KUBECONFIG_PATH}} --skip-diff-on-install --suppress-diff
    status:
      - helmfile --file {{.K8S_DIR}}/config/helmfile.yaml status --kubeconfig {{.KUBECONFIG_PATH}}

  label-worker-nodes:
    desc: "Label worker/agent nodes with node-role.kubernetes.io/worker=true"
    cmds:
      - |
        echo "üîÑ Labeling worker/agent nodes..."
        for ((i=0; i<{{.WORKERS}}; i++)); do
          NODE_NAME="k3d-{{.CLUSTER_NAME}}-agent-${i}"
          if ! kubectl --kubeconfig {{.KUBECONFIG_PATH}} get node ${NODE_NAME} -o jsonpath='{.metadata.labels}' | grep -q 'node-role\.kubernetes\.io/worker'; then
            kubectl --kubeconfig {{.KUBECONFIG_PATH}} label node ${NODE_NAME} node-role.kubernetes.io/worker=true --overwrite
            echo "‚úÖ Labeled node ${NODE_NAME} as worker"
          else
            echo "‚ÑπÔ∏è Node ${NODE_NAME} is already labeled as worker"
          fi
        done
    status:
      - |
        LABELED_COUNT=0
        for ((i=0; i<{{.WORKERS}}; i++)); do
          NODE_NAME="k3d-{{.CLUSTER_NAME}}-agent-${i}"
          if kubectl --kubeconfig {{.KUBECONFIG_PATH}} get node ${NODE_NAME} -o jsonpath='{.metadata.labels}' | grep -q 'node-role\.kubernetes\.io/worker'; then
            ((LABELED_COUNT++))
          fi
        done
        [ "$LABELED_COUNT" -eq "{{.WORKERS}}" ]

  fetch-service-secrets:
    desc: Fetch secrets for enabled services
    silent: true
    cmds:
      - |
        if [ "{{.USE_SERVICE_PRESETS}}" = "true" ]; then
          # Get list of enabled services first
          ENABLED_SERVICES=($(yq e '.environment.services[] | select(.enabled == true) | .name' {{.CONFIG_FILE}}))
          
          OUTPUT_FILE="{{.K8S_DIR}}/service-secrets.txt"
          > $OUTPUT_FILE  # Clear the file before writing

          for SERVICE in "${ENABLED_SERVICES[@]}"; do
            # Check if service is password-protected in presets
            IS_PROTECTED=$(yq e ".service_auth_presets.$SERVICE.password-protected" {{.ROOT_DIR}}/templates/service_presets.yaml)
            if [ "$IS_PROTECTED" = "true" ]; then
              # Get secret name and field from presets
              SECRET_NAME=$(yq e ".service_auth_presets.$SERVICE.secret-name" {{.ROOT_DIR}}/templates/service_presets.yaml)
              PASSWORD_FIELD=$(yq e ".service_auth_presets.$SERVICE.password-field" {{.ROOT_DIR}}/templates/service_presets.yaml)
              PASSWORD=$(kubectl get secret $SECRET_NAME -n $SERVICE -o jsonpath="{.data.$PASSWORD_FIELD}" | base64 --decode)
              echo "Service $SERVICE, Password: $PASSWORD" >> $OUTPUT_FILE
            fi
          done

          if [ -s "$OUTPUT_FILE" ]; then
            echo "üîë Passwords for enabled password-protected services have been written to $OUTPUT_FILE"
          fi
        else
          echo "‚ÑπÔ∏è  Service presets are disabled (use-service-presets: false)"
          echo "üëâ You are responsible for managing service secrets."
          echo "   Refer to each service's helm chart documentation for configuration"
        fi
